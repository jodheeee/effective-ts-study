export const item1 = "타입스크립트와 자바스크립트의 관계 이해하기";
// 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있어, 런타임 오류를 발생시키는 코드를 찾아낸다.
// 타입체커를 통과하더라도 런타임 오류는 발생할 수 있으므로 안전 장치로만 생각하는 것이 좋다.

export const item2 = "타입스크립트 설정 이해하기";
// tsconfig.json 설정
// noImplicitAny: 변수들이 미리 정의된 타입을 가져야 하는지 여부 (false인 경우, 암시적 any 가능)
// 해당 설정은 기존 자바스크립트 프로젝트를 타입스크립트로 전환하는 상황을 제외하고는 지양하는 것이 좋다.
// strictNullChecks: null과 undefined가 모든 타입에서 허용되는지 확인하는 설정
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const x: number | null = null;
// => strict 설정을 통해 둘 다 잡을 수 있음

export const item3 = "코드 생성과 타입이 관계없음을 이해하기";
// 타입스크립트의 컴파일(최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일)과 타입체크는 완벽히 독립적으로 이루어진다.
// 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에, 런타임에 비용이 전혀 들지 않는다.
// 런타임 타입과 선언된 타입은 일치하지 않을 수 있다. (ex. API 호출에 대한 response 값은 런타임에서 파악할 수 있음)

export const item4 = "구조적 타이핑에 익숙해지기";
// 자바스크립트는 본질적으로 덕 타이핑(duck typing) 언어이다.
// 직접적인 관계 선언을 하지 않아도 객체의 구조가 일치하면 타입이 호환된다.

export const item5 = "any 타입 지양하기";
// any 타입에는 타입 안전성이 없다.
// 타입체커와 타입스크립트 언어 서비스를 무력화시키며, 타입 시스템의 신뢰도를 떨어뜨리기 때문에 지양하는 것이 좋다.
