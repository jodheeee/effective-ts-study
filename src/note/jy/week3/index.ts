export const item19 = "추론 가능한 타입을 사용해 장황한 코드 방지하기";
/**
 * 타입스크립트가 타입을 추론할 수 있다면 타입 구문은 생략하는 것이 좋다.
 * 추론할 수 있는 경우에도 객체 리터럴과 함수 반환에는 타입 명시를 고려해볼 수 있다. 이로 인해 사용자 코드 위치가 아닌 선언 위치에서 오류를 잡을 수 있다.
 */

export const item20 = "다른 타입에는 다른 변수 사용하기";
/**
 * 변수 값은 변할 수 있지만 타입은 일반적으로 바뀌지 않는다.
 * 변수를 재사용하기보다는 분리하여 선언하는 것이 타입 추론 및 가독성에 도움이 된다.
 */

export const item21 = "타입 넓히기";
/**
 * 타입 스크립트는 widening을 통해서 변수 값의 타입을 추론하게 된다.
 * const, 타입 구문, 문맥, as const를 통해 좁은 타입 추론을 유지할 수 있다.
 */

export const item22 = "타입 좁히기";
/**
 * 명시적 태그를 붙이거나 사용자 정의 타입 가드를 사용하여 타입 좁히기를 할 수 있다.
 */

export const item23 = "한꺼번에 객체 생성하기";
/**
 * 속성은 객체 전개, 구조 분해 할당을 통해 한꺼번에 추가할 수 있다.
 */

export const item24 = "일관성 있는 별칭 사용하기";
/**
 * 별칭(alias)은 타입 좁히기를 방해라 수 있기 때문에 사용할 때에 일관되게 사용해야 한다.
 * 구조분해 할당을 통해 일관된 이름을 사용하는 것이 좋다.
 */

export const item25 = "비동기 코드에는 콜백 대신 async 함수 사용하기";
/**
 * 콜백보다는 async await를 사용하여 비동기 코드를 작성하는 것이 좋다.
 */

export const item26 = "타입 추론에 문맥이 어떻게 사용되는지 이해하기";
/**
 * 타입스크립트는 타입을 추론할 때 값만 고려하지 않고 문맥을 고려한다.
 * 변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 한다.
 */

export const item27 = "함수형 기법과 라이브러리로 타입 흐름 유지하기";
/**
 * 타입 흐름은 시간 절약을 위해서는 내장된 함수형 기법과 로대시같은 유틸리티 라이브러리를 사용하는 것이 좋을 수 있다.
 */
