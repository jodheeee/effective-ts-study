export const week = 1;

// item 1
// 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템
// 따라서 런타임 오류를 발생시킬 수 있는 것이다.

// item 3
// 타입스크립트에서 트랜스파일과 코드의 타입 오류 체크는 완벽히 독립적이다.
// 타입스크립트가 자바스크립트로 변활될 때 코드 내의 타입에는 영향을 주지 않는다.
// 또한 그 자바스크립트의 실행 시점에도 타입은 영향을 미치지 않는다.
// 타입을 명확하게 하려면, 런타임에 타입정보를 유지하는 방법이 필요하다.
// 런타임에 타입 정보를 유지하는 방법
//   1. 보정 : if('x' in object) …
//   2. 태그 기법 : if(object.key === 'x') …
// 타입스크립트는 런타임 오버헤드가 없는 대신, 빌드타임 오버헤드가 있다.
// 따라서 코드 생성은 타입 시스템과 무관해서 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.

// item 6
// 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법이 좋다.

// item 7
// 무슨말인지 도통 모르겠다.

// item 8
// 타입인지 값인지 구분하는 방법은 타입 생성시 지명에 대한 규칙성이 있다면 해결된다.
// 타입은 값을 가지지 않지만 class enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있다.

// item 9
// 타입스크립트 타입은 단언보다는 추론을 지향한다.
// 하지만 타입스크립트는 DOM에 접근할 수 없기 때문에 document.querySelector('...') 으로 선언 된것은
// 타입 단언문을 쓰는 것이 타당하다.
// 변수의 접미사로 !를 쓴다면 null이 아니라는 단언문으로 해석된다.
const elNull = document.getElementById("foo"); // type: HTMLElement | null
const el = document.getElementById("foo")!; // type: HTMLElement
// 접미사 !는 그 값이 null이 아니라고 확신할 수 있을 때 사용해야한다.
// 그렇지 않다면, null인 경우를 체크하는 조건문을 사용해야 한다.

// item 10
// 래퍼 객체란 ?
// 순간적으로 생성되었다 사라지는 객체
// 원시타입의 메서드를 호출하면,
//   1. 순간적으로 원시타입에 해당하는 '객체'가 생성되고,
//   2. 이 '객체'의 메서드가 호출된다.
//   3. 메서드 처리가 끝나면 이 '객체'는 사라지고,
//   4. 원래의 원시타입만 남는다.
// 왜 쓰지 ?
// 객체는 다양한 프로퍼티와 메서드가 있어서 유용하지만, 무겁고 느리다는 단점이 있다.
// 원시타입은 가볍고 빠르지만, 값이 하나 뿐이라는 단점이 있다.
// 원시타입을 그대로 쓰자! 대신, 메서드를 호출할 때만 잠깐 객체로 바꾸자.
// 따라서, 특별한 경우를 제외하면, 원시타입을 그대로 사용하는게 권장
// 타입스크립트도 마찬가지로 객체 레퍼 타입은 지양하고, 기본형 타입을 사용해야 한다.

// item 11
// 리터럴 ?
// 변수에 넣는 변하지 않는 데이터를 의미
const a = 1; // a: 상수 , 1: 리터럴
// 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
// 잉여 속성 체크에는 한계까 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너 뛸 수 도 있다.

// item 12
// 타입스크립트에서는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용 할 수 있어
// 함수 문장 보다는 함수 표현식을 사용하는 것이 좋다.
